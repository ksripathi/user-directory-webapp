#+TITLE: Data Model of the User Directory Application
#+AUTHOR: VLEAD
#+DATE: [2016-05-11 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../org-templates/level-1.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export

* Initialization

** Imports for Python API
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
# -*- coding: utf-8 -*-

from collections import OrderedDict

from flask.ext.sqlalchemy import SQLAlchemy
from flask import current_app, request
from sqlalchemy.orm import relationship
import sqlalchemy.types as types

import os
import re
from urlparse import urlparse
from datetime import datetime
import json

from op_exceptions import AttributeRequired, ConstraintError, NotAuthorizedError
from utils import *

db = SQLAlchemy()

#system = None
# Abstract class to hold common methods
class Entity(db.Model):

    __abstract__ = True

    # save a db.Model to the database. commit it.
    def save(self):
        db.session.add(self)
        db.session.commit()

    # update the object, and commit to the database
    def update(self, **kwargs):
        for attr, val in kwargs.iteritems():
            setter_method = "set_" + attr
            try:
                self.__getattribute__(setter_method)(val)
            except Exception as e:
                raise e

        self.save()

    #print "Setting new val"
    #print "Calling %s on %s" % (method_to_set, curr_entity)
    #try:
    #    getattr(record, method_to_set)(new_val)
    #except Exception as e:
    #pass

    def delete(self):
        db.session.delete(self)
        db.session.commit()

#+END_SRC


** Imports and Initialization of testcases for Python API

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
# -*- coding: utf-8 -*-
import unittest
from flask.ext.testing import TestCase
from datetime import datetime
# import json

from src.db import *
from src.app import create_app
from src.op_exceptions import AttributeRequired, ConstraintError, NotAuthorizedError


config = {
    'SQLALCHEMY_DATABASE_URI': ''
}

system = None

def setUp():
    global system
    a_role = Role("admin")
    u_role = Role("user")
    a_role.save()
    u_role.save()
    admin_user = User(name="admin", 
                          email="app-admin@vlabs.ac.in", 
                          role=Role.get_by_id(1))
    admin_user.save()       
    
    System.created = False
    system = System()
    session = Session(user = admin_user)
    #print " *************SETUP****************"
    #print system
    #print " *************SETUP****************"
    #global system
    #system.login(admin_user)
    system.session_set.append(session)
    system.user_set = User.get_all()
    #print len(system.user_set)


def tearDown():
    global system
    system.user_set = []
    #system.session_set = []
#+END_SRC



** Imports for utility functions
   
#+BEGIN_SRC python :tangle ../../src/utils_new.py :eval no

# module to hold all utilities/helper functions

import json

from flask import make_response, current_app

import re


#+END_SRC


* Utility Functions

*** is_alphabetic_string(value)
    This function take an argument and checks whether the argument contains
    only alphabets.

#+BEGIN_SRC  python :tangle ../../src/utils.py :eval no
def is_alphabetic_string(value):
    if re.search('[^a-zA-Z. ]+', value):
        return False
    else:
        return True
#+END_SRC


*** is_email(value)
    Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
    Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/utils.py :eval no
def is_email(value):
    if re.search('[^@]+@[^@]+\.[^@]+', value):
        return True
    else:
        return False
#+END_SRC



*** Other function for REST

#+BEGIN_SRC python :tangle ../../src/utils_new.py :eval no

# module to hold all utilities/helper functions

# return a list of dicts as json with correct mime types
# flask does not provide a jsonify for lists; hence this method
def jsonify_list(data):
    if type(data) is not list:
        raise Exception('jsonify_list function accepts only a list')

    return make_response(json.dumps(data), 200,
                         {'content-type': 'application/json'})


# take in a flask request object and try to parse out a dictionary from the
# request
# try to find if request is as JSON first, then look into forms, finally force
# find it.
# If not found return a dict; else return the parsed data
def parse_request(request):
    if request.json:
        # print 'found in request.json'
        data = request.get_json()

    elif request.data:
        # print 'found in request.data'
        data = json.loads(request.data)

    elif request.form:
        # print 'found in request.form'
        data = request.form.to_dict()
        # try to detect if form contains integers and boolean data and attempt
        # to convert them
        # FIXME: is this a good idea? Fix this to do it in a better way?
        for k in data:
            if is_number(data[k]):
                data[k] = int(data[k])
            if is_bool_in_str(data[k]):
                data[k] = str_to_bool(data[k])

            # print k, data[k]

    else:
        data = request.get_json(force=True)

    if not data:
        return False

    return data


# check if a given string is a number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


# check if in a given string python bool types are represented
def is_bool_in_str(s):
    if s == "True" or s == "False":
        return True
    return False


# convert python bool types in string to native bool types
def str_to_bool(s):
    if s == "True":
        return True
    if s == "False":
        return False
    return None
#+END_SRC


* Object Relational Model

** Name

*** Construction

     Name is an alphabetical string.

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class Name(object):
    value = None
    def __init__(self, value):
        # value: String 
        # if the string contains any non-alphabet and non-space character,
        # raise a type error
        if is_alphabetic_string(value):
            self.value = value
        else:
            raise TypeError('%s is not a Name!' % value)

    def __str__(self):
        return self.value
#+END_SRC


*** Test the Construction 
    We checked for both possible cases - valid name eg: John and invalid name eg:123dasd 
    
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestName(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app


    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        tearDown()

    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC


** Email

*** Construction

     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class Email(object):
    value = None
    def __init__(self, value):
        if not is_email(value):
            raise TypeError('%s is not an email!' % value)
        self.value = value

    def __str__(self):
        return self.value
#+END_SRC



*** Test the Construction
    The following test case checks for both the cases- valid email
    eg:smith@gmail.com and invalid email eg: @@@gmail.com (which raises a Type
    Error).

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestEmail(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        tearDown()

    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")
#+END_SRC



** User

*** Immutable Data
     This is the data associated with Institute type, which is immutable.

     + Id


*** Mutable Data

     These are the data associated with User type, which are mutable

     + Name  is a string
     + Email is a string
     + Role  is an object of Role class

*** User Table structure
    
|---------+--------------+------+-----+---------+----------------|
| Field   | Type         | Null | Key | Default | Extra          |
|---------+--------------+------+-----+---------+----------------|
| id      | int(11)      | NO   | PRI | NULL    | auto_increment |
|---------+--------------+------+-----+---------+----------------|
| role_id | int(11)      | YES  | MUL | NULL    |                |
|---------+--------------+------+-----+---------+----------------|
| name    | varchar(128) | NO   |     | NULL    |                |
|---------+--------------+------+-----+---------+----------------|
| email   | varchar(128) | NO   | UNI | NULL    |                |
|---------+--------------+------+-----+---------+----------------|



*** Definition
    
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class User(Entity):

    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    name = db.Column(db.String(128), nullable=False)
    email = db.Column(db.String(128), nullable=False, unique=True)

#+END_SRC


*** Constructor

**** Implementation

    Signature of the constructor of =User= is as follows:

    #+BEGIN_EXAMPLE
    usr = User(name=<object of Name>, email=<object of Email>, 
              role=<object of Role>)
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def __init__(self, **kwargs):
        if 'email' not in kwargs:
            raise AttributeRequired("email is mandatory")

        if 'name' not in kwargs:
            raise AttributeRequired("name is mandatory")

        if 'role' not in kwargs:
            raise AttributeRequired("Atleast one role is mandatory")

        self.set_email(kwargs['email'])
        self.set_name(kwargs['name'])
        self.set_role(kwargs['role'])
#+END_SRC


**** Test the constructor
     Two test cases are written below -
     i) Creating a user without role - raises Attribute Required exception
     ii) A valid case - User created with name, email and a valid role.
     
     setUp() method creates all tables and tearDown() deletes all of them.They
     are invoked before and after every test case respectively.

 #+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestUser(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        tearDown()

    def test_user_creation_without_role(self):
        print "test_user_creation_without_role"
        with self.assertRaises(AttributeRequired):
            user = User(name="Robin Smith", 
                            email="smith@gmail.com")

    def test_user_creation_with_role(self):
        print "test_user_creation_with_role"
        #role = Role("admin")
        #role.save()
        user = User(name="Robin Smith", 
                    email="smith@gmail.com",
                    role=Role.get_by_id(1))
        user.save()
        self.assertEqual(user.role.name, "admin")   
 #+END_SRC


*** Functions


**** setRole User, Role ---> NIL

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_role(self, role):
        self.role = role
#+END_SRC

***** Test setRole to a user 
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_set_roles_to_user(self):
        print "test_set_roles_to_user"
        #a_role = Role("admin")
        #role.save()
        user = User(name="Robin Smith", 
                    email="smith@gmail.com",
                    role=Role.get_by_id(1))
        user.save()
        #role = Role("user")
        #role.sa
        user.set_role(Role.get_by_id(2))
        user.save()
        users = User.get_all()
        self.assertEqual(users[1].role.name, "user")
#+END_SRC


**** setEmail
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_email(self, email):
        if not is_email(email):
            raise TypeError('email is invalid')
        else:
            self.email = email
#+END_SRC


**** setName
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_name(self, name):
        if not is_alphabetic_string(name):
            raise TypeError('Invalid name')
        else:
            self.name = name
#+END_SRC

**** setRole
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_role(self, role):
        if not isinstance(role, Role):
            raise TypeError('`role` argument should be of type Role.')
        else:
            self.role = role
#+END_SRC


**** getEmail
 #+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_email(self):
        return self.email
 #+END_SRC


**** getName
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_name(self):
        return self.name
#+END_SRC


**** getAll: Nil --> set[User]

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    @staticmethod
    def get_all():
        return User.query.all()
#+END_SRC


***** Test getAll
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_user_get_all(self):
        print "test_user_get_all"
        #role = Role("Admin")
        #role.save()
        user = User(name="Termite", 
                    email="tremite@gmail.com",
                    role=Role.get_by_id(1))
        user.save()
        users = User.get_all()
        self.assertEqual("admin", users[0].role.name)
#+END_SRC


**** getById : id --> User

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return User.query.get(id)
#+END_SRC


***** Test getById: Id --> User
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_get_user_by_id(self):
        print "test_get_user_by_id"
        #role = Role("admin")
        #role.save()
        user = User(name="Robin Smith", 
                    email="smith@gmail.com",
                    role=Role.get_by_id(1))
        user.save()
        self.assertEqual(user.get_by_id(2).role.name, "admin")
        self.assertEqual(user.get_by_id(2).name, "Robin Smith")
#+END_SRC

***** Test updateRole: Role -> Role
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_update_user(self):
        print "test_update_role"
        #a_role = Role("admin")
        #a_role.save()
        user = User(name="Robin Smith", 
                    email="smith@gmail.com",
                    role=Role.get_by_id(1))
        user.save()
        u1 = User.get_by_id(1)
        print u1.to_client()
        #u_role = Role("user")
        #u_role.save()
        u1.update(name="Duddley Rod", 
                  email="duddley@gmail.com",
                  role=Role.get_by_id(2))
        print u1.to_client()
        self.assertEqual(u1.get_by_id(1).name, "Duddley Rod")
        self.assertEqual(u1.get_by_id(1).role.name, "user")
#+END_SRC


**** toClient
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'role': self.role.to_client()
        }
#+END_SRC



** Role

*** Introduction
   A Role has got certain privileges.  In this current application, the
   privileges are understood 
   
   Different types of roles are:

   - Admin :: An admin is an user who can add, modify and delete other users
              except himself
   - User :: A User is a user who can view all other users and either modify or
             delete himself.



*** Immutable Data
    This is the data associated with Institute type, which is immutable.

     + Id


*** Mutable Data

     These are the data associated with User type, which are mutable

     + Name

*** Role Table structure
|-------+--------------+------+-----+---------+----------------|
| Field | Type         | Null | Key | Default | Extra          |
|-------+--------------+------+-----+---------+----------------|
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
|-------+--------------+------+-----+---------+----------------|
| name  | varchar(128) | NO   | UNI | NULL    |                |
|-------+--------------+------+-----+---------+----------------|



*** Definition
    
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class Role(Entity):
    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), unique=True, nullable=False)
    
    users = db.relationship('User', backref='role')
#+END_SRC


*** Constructor

    The signature of Role is defined as follows
    #+BEGIN_EXAMPLE
    role = Role(name=<Object of Name>)
    #+END_EXAMPLE

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name


#+END_SRC


*** Test Constructor
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestRole(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        tearDown()
        
    def test_role_creation(self):
        print "test_role_creation"
        role = Role.get_by_id(1)
        role.save()
        self.assertEqual(role.name, "admin")
#+END_SRC


*** Functions
**** getALL
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    @staticmethod
    def get_all():
        return Role.query.all()
#+END_SRC


**** getById : id --> Role

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    @staticmethod
    def get_by_id(id):
        return Role.query.get(id)
#+END_SRC



**** to_client
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'name': self.name
        }

#+END_SRC







** Session
   
*** Definition
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class Session(object):
    user = None
    
#+End_SRC

*** Constructor
**** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def __init__(self, **kwargs):
        if 'user' not in kwargs:
            raise AttributeRequired("user is mandatory")
        else:
            self._set_user(kwargs['user'])
#+END_SRC

*** Test constructor
    
    test_session_creation() creates a User object  add a Session for him thus tests the
    Session Constructor.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestSession(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        tearDown()
        

    def test_session_creation(self):
        print "test_session_creation"
        #system = setUp()
        user = User(name="Robin Smith", 
                    email="smith@gmail.com",
                    role=Role.get_by_id(1))
        session = Session(user=user)
        self.assertEqual(session.user.role, Role.get_by_id(1))
        #tearDown(system)
#+END_SRC

*** Operations

**** getUser
     This method returns the user object from his respective Session.

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_user(self):
        return self.user
#+END_SRC

***** Test case 
      Creates a new User and a Session for him.Calls session.get_user() and
      checks if the user that it returns is the same the new user.
      
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_get_user(self):
        #system = setUp()
        print "test_get_user"
        user = User(name = "def", email = "def@gmail.com", role = Role.get_by_id(1))
        session = Session(user = user)
        new_user = session.get_user()
        self.assertEquals(new_user, user)
        #tearDown(system)
#+END_SRC
    
**** _set_user
     This method attaches a user with his Session
***** Implementation 

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def _set_user(self, user):   
        if not isinstance(user, User):
            raise TypeError('`user` argument should be of type User.')
        else:
            self.user = user
#+END_SRC

***** Test
      Tests set_user method of Session class.      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_set_user(self):
        #system = setUp()
        print "test_set_user"
        user = User(name = "def", email = "def@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        session._set_user(user)
        self.assertEquals(session.user, user)
        #tearDown(system)
#+END_SRC
    
**** toClient
    
     This method returns a dictionary with =key= - 'session'= , =value= - user
     dictionary.

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def to_client(self):
        return {
            'session': self.user.to_client()
        }
#+END_SRC

** System
   This class maintains user_set (list of all users in the directory),
   session_set (list of all sessions currently logged in) 
   All the operations of the user directory web-app are defined here.
   In the REST API every call is made using a system object.
   
*** Definition
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class System(object):

    user_set = []
    session_set = []
    created = False
    
#+END_SRC

*** Constructor
    System Constructor ensures that only one System object can be created and
    initializes user_set and session_set for the system object.

**** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no

    def __init__(self):
        if System.created == True:
            raise ConstraintError("System has already been created")
        else:
            
            System.created = True
           
            self.session_set = []
            self.user_set = []

#+END_SRC

**** Test Constructor
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestSystem(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        tearDown()
    
    def test_system_creation(self):
        print "test_system_creation"
        global system
      
        new_users = system.user_set
        new_user = new_users[0]
        self.assertEquals(new_user.email, "app-admin@vlabs.ac.in")
        
        
#+END_SRC

*** Operations
**** add_user
     add_user method ensures only an admin who is logged in can add an user. 
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def add_user(self, user,session):
        if session in self.session_set:
            if session.user.role == Role.get_by_id(1):
                a= Audit(session=json.dumps(session.to_client()),entity="User",old_data="",operation="createuser",status="success",timestamp=datetime.now())
                a.save()
                user.save()
                self.user_set = User.get_all()
            else:
                a= Audit(session=json.dumps(session.to_client()),entity="User",old_data="",operation="createUser",status="failure",timestamp=datetime.now())
                a.save()
                raise NotAuthorizedError("Only admin can add")
        else:
            raise ConstraintError("Invalid Session")

#+END_SRC

***** Test
      The following test case is written to test user creation(add_user)  by an admin.
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_add_user_session_admin(self):
        global system
        #system = setUp()
        
        print "test_add_user_by_admin"
        old_user_set_length =len( system.user_set)
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        #user.save()
        system.user_set = User.get_all()
        system.add_user(user, admin_session)
        new_user_set_length = len(system.user_set)
        self.assertEquals( new_user_set_length, old_user_set_length + 1)
        #tearDown(system)
#+END_SRC
       
        The following test case tests user creation(add_user) by an =user= and
        this is not permitted. This test case asserts that a NotAuthorized
        error is raised for this case.

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def test_add_user_session_user(self):
        global system
        #system = setUp()
        print "test_add_user_by_user"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        user1 = User(name = "asdfg", email = "asdf@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #user1.save()
        system.add_user(user1, admin_session)
        system.login(user1)
        user_list = filter(lambda x: x.email == user.email,
        system.user_set)
        user_check = user_list[0]
        user_session = Session(user = user_check)
        system.session_set.append(user_session)
        #global system
        with self.assertRaises(NotAuthorizedError):
            system.add_user(user, user_session)
        #tearDown(system)
#+END_SRC
       
        The following test case tests user creation(add_user) by an =admin= who
        isn't logged into the system. This test case asserts that a Constraint
        Error is raised for this particular case.

#+BEGIN_SRC python :tangle ../../src/db.py :eval no

    def test_add_user_session_invalid(self):
        global system
        #system = setUp()
        print "test_add_user_session_invalid"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        user1 = User(name = "asdfg", email = "asdf@gmail.com", role = Role.get_by_id(1))
        
        session = Session(user = user1)
        #global system
        with self.assertRaises(ConstraintError):
            system.add_user(user, session)
        #tearDown(system)


#+END_SRC

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
#system = None
#+END_SRC

**** del_user
     This method ensures that only admins who are logged in can delete other
     users and not themselves.
     Users who aren't logged in currently can be deleted by admins.

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def del_user(self, user, session):
        y=0
        print session.user.email
        print len(self.session_set)
        for x in self.session_set:
           print x.user.email
           if (x.user.email==session.user.email):
              y=1
              
        #if session in self.session_set:
        if y==1:
            if not session.user.role.name == "admin":
                raise NotAuthorizedError("Only admin can remove users")
            else:
                check = False
                for x in self.session_set:
                    if x.user.email == user.email:
                        check = True
                if not check:
                    old_data=json.dumps(user.to_client())
                    a= Audit(session=json.dumps(session.to_client()),operation="deleteUser",timestamp=datetime.now(),entity="User",old_data=old_data,status="success")
                    a.save()
                    self.del_session(user,session)

                   

                    user.delete()
                    self.user_set = User.get_all()
                else:
                    raise ConstraintError("User is still logged in")
        else:
            raise ConstraintError("Invalid session!!!")

#+END_SRC

***** Test
Test case for deletion of user by admin who is logged in.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_delete_user_session_admin(self):
        global system
        #system = setUp()
        print "test_delete_user_by_admin"
        old_user_set_length =len( system.user_set)
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user, admin_session)
        system.del_user(user, admin_session)
        new_user_set_length = len(system.user_set)
        self.assertEquals( new_user_set_length, old_user_set_length )
        #tearDown(system)
#+END_SRC

Test case for deletion of user by an =user= 

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_delete_user_session_user(self):
        global system
        #system = setUp()
        print "test_delete_user_by_user"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        user1 = User(name = "asdfg", email = "asdf@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user1, admin_session)
        system.login(user1)
        system.add_user(user, admin_session)
        user_list = filter(lambda x: x.email == user.email,
        system.user_set)
        user_check = user_list[0]
        user_session = Session(user = user_check)
        system.session_set.append(user_session)
        #global system
        with self.assertRaises(NotAuthorizedError):
            system.del_user(user, user_session)
        #tearDown(system)
#+END_SRC

Test case for deletion of user who is currently logged in.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_delete_user_session_logged_in(self):
        global system
        #system = setUp()
        print "test_delete_user_session_logged_in"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        user1 = User(name = "asdfg", email = "asdf@gmail.com", role = Role.get_by_id(1))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        system.login(user)
        
        with self.assertRaises(ConstraintError):
            system.del_user(user, admin_session)
        #tearDown(system)

#+END_SRC

Test case for deletion of user by an admin who isn't logged in.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_delete_user_session_invalid(self):
        global system
        #system = setUp()
        print "test_delete_user_session_invalid"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        user1 = User(name = "asdfg", email = "asdf@gmail.com", role = Role.get_by_id(1))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        system.login(user)
        #system.add_user(user1, admin_session)
        #user_session_list = filter(lambda x: x.user.role == Role.user, system.session_set)
        #user_session = user_session_list[0]
        session = Session(user = user1)
        #global system
        with self.assertRaises(ConstraintError):
            system.add_user(user, session)
        #tearDown(system)


#+END_SRC
    
**** show_users
     This method returns all the users in the user_set(user directory).
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def show_users(self,session):
        if session in self.session_set:
            return self.user_set
        else:
            raise ConstraintError("Not a valid session")

#+END_SRC

***** Test
      
      Test case for show_users()
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_show_users_valid(self):
        print "test_show_users_valid"
        global system
        #system = setUp()
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user,admin_session)
        system.login(user)
        current_session = system.session_set[0]
        
        check_user_set = system.show_users(current_session)
        self.assertEquals(check_user_set, system.user_set)
        #tearDown(system)

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_show_users_invalid(self):
        print "test_show_users_invalid"
        global system
        #system = setUp()
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        #admin_sessions_list = filter(lambda x: x.user.role == Role.admin, system.session_set)
        #admin_session = admin_sessions_list[0]
        #system.add_user(user,admin_session)
        #system.login(user)
        current_session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            system.show_users(current_session)
        #tearDown(system)

#+END_SRC

**** get_users_from_database
     
     This method returns all the users from the User table in the database.

#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_users_from_database(self):
        self.user_set = User.get_all()

#+END_SRC


**** get_user_by_email
     
     This method takes in an email and session as a parameter.Checks if the
     session is valid(that is if the user is logged in). It returns the user
     with the corresponding email if the user exists in the user_set.
    
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_user_by_email(self, email, session):
        user_check = filter(lambda x: x.email == email, self.user_set)
        if session in self.session_set:
            if user_check:
                return user_check[0]
            else:
                raise ConstraintError("Invalid session")
        else:
            raise ConstraintError("No user by this email")

#+END_SRC

***** Test
      Testing Get user when an existing email is passed.
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_get_user_by_email_existing(self):
        print "test_get_user_by_email_existing"
        #system = setUp()
        global system
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        
        user_check = system.get_user_by_email("abcdef@gmail.com",admin_session)
        self.assertEquals( user_check , user)
        #tearDown(system)
#+END_SRC
      
       Testing Get user when a non-existent email is passed.
 
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no   
    def test_get_user_by_email_non_existent(self):
        print "test_get_user_by_email_non_existent"
        #system = setUp()
        global system
        user = User(name = "ancd", email = "ancd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        system.login(user)
        with self.assertRaises(ConstraintError):
            email_check = system.get_user_by_email("abcbdbejf@gmail.com",admin_session)
        #tearDown(system)
#+END_SRC
        
        Testing get_user_by_email when an invalid session is passed(that is
        session not present in session_set)
        
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no  
    def test_get_user_by_email_invalid_session(self):
        print "test_get_user_by_email_invalid_session"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.get_user_by_email("abcdf@gmail.com",session)
        #tearDown(system)

#+END_SRC

**** make_user

***** Implementation
      This method calls add_user.
      
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
     
    def make_user(self,name,email,role,session):
        if session in self.session_set:
            if(session.user.role==Role.get_by_id(1)):
                user=User(name=name,email=email,role=role)
                self.add_user(user,session)  
            else:
                raise NotAuthorizedError('only admin can create user')
        else:
            raise ConstraintError("Invalid Session")

#+END_SRC

***** Test
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no      
    def test_make_user_session_user(self):
        global system
        #system = setUp()
        print "test_make_user_session_user"
        old_users=system.user_set
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user,admin_session)
        system.login(user)
        user_list = filter(lambda x: x.email == user.email,
        system.user_set)
        user_check = user_list[0]
        user_session = Session(user = user_check)
        system.session_set.append(user_session)
        with self.assertRaises(NotAuthorizedError):
            system.make_user("abc", "abcd@gmail.com", user.role, user_session)
        #tearDown(system)

    def test_make_user_session_admin(self):
        global system
        #system = setUp()
        print "test_make_user_session_admin"
        #old_users=system.user_set
        #user = User(name = "abcd", email = "abcd@gmail.com", role = Role.user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #session = Session(user = user)
        old_user_set_length = len(system.user_set)
        system.make_user("abc", "abcd@gmail.com", admin_session.user.role, admin_session)
        new_user_set_length = len(system.user_set)
        self.assertEquals(old_user_set_length + 1, new_user_set_length)
        #tearDown(system)

    def test_make_user_session_invalid_session(self):
        global system
        #system = setUp()
        print "test_make_user_session_admin"
        old_users=system.user_set
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        #admin_session_list = filter(lambda x: not x.user.role == Role.admin, system.session_set)
        #admin_session = admin_session_list.pop()
        session = Session(user = user)
        with self.assertRaises(ConstraintError):
            system.make_user("abc", "abcd@gmail.com", Role.get_by_id(1), session)
        #tearDown(system)

#+END_SRC
**** get_email_of_user
     This method takes in user and session as parameter and returns the email
     of the user.
     
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_email_of_user(self, user, session):
        if session in self.session_set:
            if user in self.user_set:
                return user.email  
            else:
                raise ConstraintError('User does not exist')
        else:
            raise ConstraintError("Invalid Session")

#+END_SRC

***** Test 
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_get_email_of_user_valid(self):
        #system = setUp()
        global system
        print "test_get_email_of_user_valid"
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user, admin_session)
        system.login(user)
        
        user_check = system.get_email_of_user(user, admin_session)
        self.assertEquals( user_check , user.email)
        #tearDown(system)
    
    def test_get_email_of_user_invalid_user(self):
        #system = setUp()
        global system
        print "test_get_email_of_user_invalid_user"
        user = User(name = "ancd", email = "ancd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #system.add_user(user, admin_session)
        #system.login(user)
        with self.assertRaises(ConstraintError):
            email_check = system.get_email_of_user(user ,admin_session)
        #tearDown(system)
    
    def test_get_email_of_user_invalid_session(self):
        print "test_get_email_of_user_invalid_session"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.get_email_of_user(user ,session)
        #tearDown(system)

#+END_SRC    

**** get_name_of_user
     This method takes in user and session as parameters and returns the name
     of the user if he exists in user_set.
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_name_of_user(self, user, session):
        if session in self.session_set:
            if user in self.user_set:
                return user.name  
            else:
                raise ConstraintError('User does not exist')
        else:
            raise ConstraintError("Invalid Session")


#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_get_name_of_user_valid(self):
        print "test_get_name_of_user_valid"
        #system = setUp()
        global system
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user, admin_session)
        system.login(user)
        
        user_check = system.get_name_of_user(user, admin_session)
        self.assertEquals( user_check , user.name)
        #tearDown(system)
    
    def test_get_name_of_user_invalid_user(self):
        print "test_get_name_of_user_invalid_user"
        #system = setUp()
        global system
        user = User(name = "ancd", email = "ancd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #system.add_user(user, admin_session)
        #system.login(user)
        with self.assertRaises(ConstraintError):
            email_check = system.get_name_of_user(user ,admin_session)
        #tearDown(system)
    
    def test_get_name_of_user_invalid_session(self):
        print "test_get_name_of_user_invalid_session"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.get_name_of_user(user ,session)
        #tearDown(system)
        
#+END_SRC    


**** set_email_of_user
     
     This method takes in user, email and session as parameters and sets email
     of the user passed, only  if the session is valid and only if the session
     is of an admin or if the user is editing himself.
     This method also ensures that an existing email cannot be set again to an
     other user.

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_email_of_user(self, user, email, session):
        #global system
        #print self.session_set
        #for x in self.session_set:
        #    print x.user.email
        a = Audit(session=json.dumps(session.to_client()), entity="User",
                        old_data=json.dumps(user.to_client()), operation="updateUserEmail", status="Ongoing", timestamp=str(datetime.now()) )
        a.save()

        if session in self.session_set:
            check = filter(lambda x: x.email == email, self.user_set)
            if not check:
                if user in self.user_set:
                    if session.user.role.name == "admin":
                        user.set_email(email)
                        user.update()
                        a.change_status("Success")
                        self.user_set = User.get_all()
                    elif session.user.email == user.email:
                        user.set_email(email)
                        user.update()
                        a.change_status("Success")
                        self.user_set = User.get_all()
                    else:
                        a.change_status("Failure")
                        raise NotAuthorizedError("You don't have permission to change the email")                        
                else:
                    a.change_status("Failure")
                    raise ConstraintError('User does not exist')
            else:
                a.change_status("Failure")
                raise ConstraintError("Email already exists")
        else:
            a.change_status("Failure")
            raise ConstraintError("Invalid Session")

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_set_email_of_user_valid_admin(self):
       
        print "test_set_email_of_user_valid_admin"
        global system
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #system.login(admin_user)
        system.add_user(user, admin_session)
        system.login(user)
        #user_session = Session(user = user)
        #system.session_set.append(user_session)
        system.set_email_of_user(user, "abcdef123@gmail.com", admin_session)
        user_check = system.get_email_of_user(user, admin_session)
        self.assertEquals( user_check , user.email)
    
    def test_set_email_of_user_valid_user(self):
        global system
        #system = setUp()
        print "test_set_name_of_user_valid_user"
        user = User(name = "ancd", email = "ancd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        system.login(user)
        user_list = filter(lambda x: x.email == user.email,
        system.user_set)
        user_check = user_list[0]
        user_session = Session(user = user_check)
        system.session_set.append(user_session)
        system.set_email_of_user(user, "abcdefghi@gmail.com", user_session)
        user_check = system.get_email_of_user(user, admin_session)
        self.assertEquals(user_check, user.email)
        #tearDown(system)       
    
    def test_set_email_of_user_invalid_session(self):
        print "test_set_email_of_user_invalid_session"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.set_email_of_user(user, "abcdef@gmail.com", session)
        #tearDown(system)
    

    def test_set_email_of_user_invalid_email(self):
        print "test_set_name_of_user_invalid_email"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.set_email_of_user(user, "abcd@gmail.com", admin_session)
        #tearDown(system)
        
#+END_SRC


**** set_name_of_user
     
     This method takes in user, email and session as parameters and sets email
     of the user passed, if the session is valid and only if the session is of
     an admin or if the user is editing himself.
     
     
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def set_name_of_user(self, user, name, session):
        #global system
        #print self.session_set
        #for x in self.session_set:
        #    print x.user.email
        a = Audit(session=json.dumps(session.to_client()), entity="User",
                        old_data=json.dumps(user.to_client()), operation="updateUserName", status="Ongoing", timestamp=str(datetime.now()) )
        a.save()
        if session in self.session_set:
            #check = filter(lambda x: x.email == email, self.user_set)
            #if not check:
            if user in self.user_set:
                if session.user.role.name == "admin":
                    user.set_name(name)
                    user.update()
                    a.change_status("Success")
                    self.user_set = User.get_all()
                elif session.user.email == user.email:
                    user.set_name(name)
                    user.update()
                    a.change_status("Success")
                    self.user_set = User.get_all()
                else:
                    a.change_status("Failure")
                    raise NotAuthorizedError("You don't have permission to change the name")
            else:
                a.change_status("Failure")
                raise ConstraintError('User does not exist')
        else:
            a.change_status("Failure")
            raise ConstraintError("Invalid Session")

#+END_SRC



**** get_role_of_user
     
     This method returns the role of the user passed in as parameter.
     
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def get_role_of_user(self, user, session):
        if session in self.session_set:
            if user in self.user_set:
                return user.role  
            else:
                raise ConstraintError('User does not exist')
        else:
            raise ConstraintError("Invalid Session")


#+END_SRC


***** Test

      This test case checks the valid case, when the role of a user has to be
      retrieved passing a current logged in session.       
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_get_role_of_user_valid(self):
        print "test_get_role_of_user_valid"
        #system = setUp()
        global system
        user = User(name = "abcdef", email = "abcdef@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user, admin_session)
        system.login(user)
        
        user_check = system.get_role_of_user(user, admin_session)
        self.assertEquals( user_check , user.role)
        #tearDown(system)
#+END_SRC   

      This test case checks the invalid case, when the role of a user who does
      not exist has to be retrieved passing a current logged in session.       
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
  
    def test_get_role_of_user_invalid_user(self):
        print "test_get_role_of_user_invalid_user"
        #system = setUp()
        global system
        user = User(name = "ancd", email = "ancd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #system.add_user(user, admin_session)
        #system.login(user)
        with self.assertRaises(ConstraintError):
            email_check = system.get_role_of_user(user ,admin_session)
        #tearDown(system)
    
    def test_get_role_of_user_invalid_session(self):
        print "test_get_role_of_user_invalid_session"
        #system = setUp()
        global system
        user = User(name = "abcd", email = "abcd@gmail.com", role = Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        session = Session(user = user)
        
        with self.assertRaises(ConstraintError):
            email_check = system.get_role_of_user(user ,session)
        #tearDown(system)       
#+END_SRC    




**** login

     This method adds a user to the session_set 

***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no

    def login(self, user):
        if not user in self.user_set:
            raise ConstraintError("User not in system")
        else:
            self.add_session(user)
#+END_SRC

***** Test
      Test case(valid case) for a existing user login.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_login_valid(self):
        print "test_login_valid"
        global system
        #system = setUp()
        user = User(name = "abcdefghi", email = "abcdefghi@gmail.com", role =
        Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        old_session_set_length = len(system.session_set)                 
        system.login(user)
        new_session_set_length = len(system.session_set)
        self.assertEquals(old_session_set_length + 1, new_session_set_length)
        #tearDown(system)

#+END_SRC

***** Test
      Test case when an non-existing user login in. (invalid case)
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_login_invalid(self):
        print "test_login_invalid"
        global system
        #system = setUp()
        user = User(name = "abcdef", email = "abcdef@gmail.com", role =
        Role.get_by_id(2))
        with self.assertRaises(ConstraintError):
            system.login(user)
        #tearDown(system)

#+END_SRC        




**** logout
     
     This method removes a user from the session_set.
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no

    def logout(self, user, session):
        if session in self.session_set:
            if user in self.user_set:               
                self.del_session(user, session)
            else:
                raise ConstraintError("user not in system")

        else:
            raise ConstraintError("Invalid session")

#+END_SRC

***** Test
      test_logout_valid tests for the valid case when a user whose session
      exists in the session set logs out.
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_logout_valid(self):
        print "test_logout_valid"
        global system
        #system = setUp()
        user = User(name = "abcdefghi", email = "abcdefghi@gmail.com", role =
        Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        old_session_set_length = len(system.session_set)
        system.login(user)
        user_list = filter(lambda x: x.email == user.email,
        system.user_set)
        user_check = user_list[0]
        user_session = Session(user = user_check)
        system.session_set.append(user_session)
        system.logout(user, user_session)
        new_session_set_length = len(system.session_set)
        self.assertEquals(old_session_set_length , new_session_set_length)
        #tearDown(system)

#+END_SRC

***** Test

      test_logout_invalid_user tests for the invalid case when a user whose
      session does not exist in the session set logs out.
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no


    def test_logout_invalid_user(self):
        print "test_logout_invalid_user"
        global system
        #system = setUp()
        user = User(name = "abcdefghi", email = "abcdefghi@gmail.com", role =
        Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #system.add_user(user, admin_session)
        #old_session_set_length = len(system.session_set)
        #system.login(user)
        #user_session_list = filter(lambda x: x.user.email == user.email,
        #system.session_set)
        #user_session = user_session_list[0]
        #system.logout(user, user_session)
        #new_session_set_length = len(system.session_set)
        #self.assertEquals(old_session_set_length , new_session_set_length)
        with self.assertRaises(ConstraintError):
            system.logout(user, admin_session)
        #tearDown(system)

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_logout_invalid_session(self):
        print "test_logout_invalid_session"
        global system
        #system = setUp()
        user = User(name = "abcdefghi", email = "abcdefghi@gmail.com", role =
        Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        system.add_user(user, admin_session)
        #old_session_set_length = len(system.session_set)
        system.login(user)
        #user_session_list = filter(lambda x: x.user.email == user.email,
        #system.session_set)
        #user_session = user_session_list[0]
        #system.logout(user, user_session)
        #new_session_set_length = len(system.session_set)
        #self.assertEquals(old_session_set_length , new_session_set_length)
        session = Session(user = user)
        with self.assertRaises(ConstraintError):
            system.logout(user, session)
        #tearDown(system)

#+END_SRC

**** add_session
     This method takes in user object as a parameter and if he exists in the
     user_set adds him to the session set.
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no

    def add_session(self, user):
        check = filter(lambda x: x.email == user.email, self.user_set)
        if check:
            session = Session(user = user)
            a = Audit(session=json.dumps(session.to_client()), entity="System",
                     old_data=" ", operation="createSession", status="success", timestamp=str(datetime.now()) )
            a.save()
            self.session_set.append(session)
        else:
            raise ConstraintError("User is not in the system")

#+END_SRC

***** Test
      The following test case asserts if after adding a valid user, the
      new_session_set's length is one greater than the old_session_set's
      length.

#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
    def test_add_session(self):
        print "test_add_session"
        #system = setUp()
        global system
        user = User(name = "ghtfdh", email = "ghtfdh@gmail.com", role = Role.get_by_id(2))
        #ession = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user,admin_session)
        old_session_set_length = len(system.session_set)
        system.add_session(user)
        new_session_set_length = len(system.session_set)
        self.assertEquals(new_session_set_length, old_session_set_length + 1)
        #tearDown(system)

#+END_SRC

**** del_session
     This method takes in user and session as parameter and deletes the session
     of the user passed. 
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def del_session(self, user, session):
        if session in self.session_set:
            if not user in self.user_set:
                raise ConstraintError("User doesn't exist in system")
            else:
                old_data=json.dumps(user.to_client())
                a= Audit(session=json.dumps(session.to_client()),operation="delete session",timestamp=datetime.now(),old_data=old_data,entity="System",status="sucess")
                a.save()
                sessions_list = self.session_set
                new_sessions = filter(lambda x: x.user.email != user.email,
                sessions_list)
                sessions_list = new_sessions
                self.session_set = sessions_list
        else:
            raise ConstraintError("Invalid session")

#+END_SRC

***** Test
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_del_session_valid(self):
        print "test_delete_session_valid"
        #system = setUp()
        global system
        user = User(name = "ghtfdh", email = "ghtfdh@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user,admin_session)
        system.login(user)
        old_session_set_length = len(system.session_set)
        system.add_session(user)
        system.del_session(user,admin_session)
        new_session_set_length = len(system.session_set)
        self.assertEquals(new_session_set_length, old_session_set_length-1)
        #tearDown(system)

    def test_del_session_invalid_user(self):
        print "test_delete_session_invalid_user"
        #system = setUp()
        global system
        user = User(name = "asddghj", email = "asljfbd@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        #system.add_user(user,admin_session)
        #old_session_set_length = len(system.session_set)
        #system.add_session(user)
        #system.del_session(user)
        #new_session_set_length = len(system.session_set)
        #self.assertEquals(new_session_set_length, old_session_set_length)
        with self.assertRaises(ConstraintError):
            system.del_session(user, admin_session)
        #tearDown(system)

    def test_del_session_invalid_session(self):
        print "test_delete_session_invalid_session"
        #system = setUp()
        global system
        user = User(name = "asddghj", email = "asljfbd@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user,admin_session)
        #old_session_set_length = len(system.session_set)
        #system.add_session(user)
        session = Session(user = user)
        #system.del_session(user)
        #new_session_set_length = len(system.session_set)
        #self.assertEquals(new_session_set_length, old_session_set_length)
        with self.assertRaises(ConstraintError):
            system.del_session(user, session)
        #tearDown(system)
    
#+END_SRC
**** show_sessions
     This method lists all the sessions in the session_set and only admin is
     authorized to view all sessions.
     
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def show_sessions(self, session):
        if not session.user.role == Role.get_by_id(1):
            raise NotAuthorizedError("Only admin can view sessions")
        else:
            return self.session_set

#+END_SRC


***** Test
      This test case checks the valid case when the session of an admin who is logged in
      passed as parameter to show_sessions.
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    def test_show_sessions_admin(self):
        print "test_show_sessions_admin"
        global system
        #system = setUp()
        #check_user_set = system.user_set
        #self.assertEquals(check_user_set, system.show_users())
        user = User(name = "ghtfdh", email = "ghtfdh@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user,admin_session)
        system.add_session(user)
        check_session_set= system.show_sessions(admin_session)
        self.assertEquals(check_session_set, system.session_set)
        #tearDown(system)

#+END_SRC


***** Test
      This test case checks the invalid case when the session of a user who is logged in
      passed as parameter to show_sessions.
      
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no

    

    def test_show_sessions_user(self):
        print "test_show_sessions_user"
        global system
        #system = setUp()
        #check_user_set = system.user_set
        #self.assertEquals(check_user_set, system.show_users())
        user = User(name = "ghtfdh", email = "ghtfdh@gmail.com", role = Role.get_by_id(2))
        session = Session(user = user)
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        #global system
        system.add_user(user,admin_session)
        system.add_session(user)
        with self.assertRaises(NotAuthorizedError):
            check = system.show_sessions(session)
        #tearDown(system)

#+END_SRC


** Audit
*** Mutable data
    There are six types of mutable data in this class:
    - Time-stamp
    - session
    - Entity
    - Operation
    - Old-data
    - Status

*** Definition
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
class Audit(Entity):
    
    __tablename__ = "audits"
    
    id = db.Column(db.Integer, primary_key=True)
    timestamp = db.Column(db.String(100))
    entity = db.Column(db.String(128), nullable=False)
    session = db.Column(db.String(128), nullable=False)
    status = db.Column(db.String(128), nullable = False)
    old_data = db.Column(db.String(128))
    operation = db.Column(db.String(128), nullable = False)


#+END_SRC

*** Constructor
**** Implementation
     
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no
    def __init__(self, **kwargs):
       
        if not 'session' in kwargs:
            raise AttributeRequired("Session is missing")
       
        if not 'operation' in kwargs:
            raise AttributeRequired("Operation is missing")
            
        if not 'entity' in kwargs:
            raise AttributeRequired("Entity is missing")
            
        self.session = json.dumps(kwargs['session'])
        self.timestamp = kwargs['timestamp']
        self.operation = kwargs['operation']
        self.entity = kwargs['entity']
        self.status = kwargs['status']
        self.old_data = json.dumps(kwargs['old_data']) 
        
#+END_SRC

*** Operations
**** changeStatus
***** Implementation
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def change_status(self, status):
        if not status:
            raise ConstraintError('Status is not passed')
        else:
            self.status = status
            self.update()

#+END_SRC
**** toClient
#+BEGIN_SRC python :tangle ../../src/db.py :eval no
    def to_client(self):
        return {
            'id': self.id,
            'session': self.session.to_client(),
            'entity': self.entity,
            'operation': self.operation,
            'timestamp': self.timestamp,
            'old-data' : self.old_data,
            'status' : self.status
        }
#+END_SRC


*** Testing
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
class TestAudit(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        setUp()

    def tearDown(self):
        tearDown()
        

    def test_Audit_creation(self):
        print "test_audit_creation for login and add user"
        user = User(name = "abcdefghi", email = "abcdefghi@gmail.com", role =
        Role.get_by_id(2))
        admin_users = filter(lambda x: x.role == Role.get_by_id(1), system.user_set)
        admin_user = admin_users[0]
        system.session_set = []
        admin_session = Session(user = admin_user)
        system.session_set.append(admin_session)
        for x in system.session_set:
            print x.to_client()
        system.add_user(user, admin_session)
        print "*********************************"
        system.login(user)
        print "Audit checking"
        x= Audit.query.all()
        print len(x)
        for i in x:
          print i.timestamp
          print i.session
          print i.old_data
        
        print "Audit checking done"
        user_session = None
        for x in system.session_set:
            if x.user.email == user.email:
                user_session = x
        system.logout(user,user_session)
        print " Audit deletion"
        
        
       
        system.del_user(user,admin_session)
        print "length after deletion"
        x=Audit.query.all()
        print len(x)
        for i in x:
          print i.timestamp
          print i.session
          print i.old_data
              
#+END_SRC

* Run Test Cases
 
#+BEGIN_SRC python :tangle ../../tests/test_db.py :eval no
if __name__ == '__main__':
    unittest.main()
#+END_SRC


